/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.18 from the
 * contents of Regex.xs. Do not edit this file, edit Regex.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Regex.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <regex.h>

#include "const-c.inc"

#define regpk     "__reg_pointer"
#define regpk_len 13

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 26 "Regex.c"

/* INCLUDE:  Including 'const-xs.inc' from 'Regex.xs' */


XS(XS_POSIX__Regex_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_POSIX__Regex_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "POSIX::Regex::constant", "sv");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 4 "const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 56 "Regex.c"
	SV *	sv = ST(0);
	const char *	s = SvPV(sv, len);
#line 18 "const-xs.inc"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid POSIX::Regex macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined POSIX::Regex macro %s, used", s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing POSIX::Regex macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 131 "Regex.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Regex.xs' from 'const-xs.inc' */


XS(XS_POSIX__Regex_regcomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_POSIX__Regex_regcomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "POSIX::Regex::regcomp", "self, regular, opts");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	self = ST(0);
	char *	regular = (char *)SvPV_nolen(ST(1));
	int	opts = (int)SvIV(ST(2));
#line 23 "Regex.xs"
    regex_t *r = (regex_t *) malloc(sizeof(regex_t));
    int err;
    char *errmsg[256];
    HV* me;

    if( r == NULL )
        croak("error allocating memory for regular");

    if( !sv_isobject(self) )
        croak("error trying to compile regular in an unblessed reference");

    me = (HV*) SvRV(self); // de-reference us
    if( SvTYPE(me) != SVt_PVHV )
        croak("error trying to compile regular in a blessed reference that isn't a hash reference");

#line 172 "Regex.c"
#line 39 "Regex.xs"
    if( (err = regcomp(r, regular, opts)) != REG_NOERROR ) {
        regerror(err, r, (char *)errmsg, 250); // 255 or 256?  screw it, 250
        croak("error compiling regular expression, %s", errmsg);
    }

    // SV**  hv_store(HV*, const char* key, U32 klen, SV* val, U32 hash); // U32 hash is the pre-computed key (if you like)
    hv_store(me, regpk, regpk_len, newSVuv((unsigned int) r), 0);

    // warn("regcomp r=%d", (unsigned int)r);
#line 183 "Regex.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_POSIX__Regex_cleanup_memory); /* prototype to pass -Wmissing-prototypes */
XS(XS_POSIX__Regex_cleanup_memory)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "POSIX::Regex::cleanup_memory", "self");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	self = ST(0);
#line 54 "Regex.xs"
    regex_t *r;
    HV* me;

    if( !sv_isobject(self) )
        croak("error trying to compile regular in an unblessed reference");

    me = (HV*) SvRV(self); // de-reference us
    if( SvTYPE(me) != SVt_PVHV )
        croak("error trying to compile regular in a blessed reference that isn't a hash reference");

    // SV**  hv_fetch(HV*, const char* key, U32 klen, I32 lval); lval indicates whether this is part of a store operation also
    r = (regex_t *) SvUV(*(hv_fetch(me, regpk, regpk_len, 0)));

#line 216 "Regex.c"
#line 68 "Regex.xs"
    // warn("DESTROY r=%d", (unsigned int)r);

    regfree(r); free(r);
#line 221 "Regex.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_POSIX__Regex_regexec); /* prototype to pass -Wmissing-prototypes */
XS(XS_POSIX__Regex_regexec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "POSIX::Regex::regexec", "self, string, opts");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	self = ST(0);
	char *	string = (char *)SvPV_nolen(ST(1));
	int	opts = (int)SvIV(ST(2));
#line 79 "Regex.xs"
    regex_t *r;
    HV* me;
    int err;
    char *errmsg[256];

    if( !sv_isobject(self) )
        croak("error trying to compile regular in an unblessed reference");

    me = (HV*) SvRV(self); // de-reference us
    if( SvTYPE(me) != SVt_PVHV )
        croak("error trying to compile regular in a blessed reference that isn't a hash reference");

    // SV**  hv_fetch(HV*, const char* key, U32 klen, I32 lval); lval indicates whether this is part of a store operation also
    r = (regex_t *) SvUV(*(hv_fetch(me, regpk, regpk_len, 0)));

#line 258 "Regex.c"
	int	RETVAL;
	dXSTARG;
#line 95 "Regex.xs"
    err = regexec(r, string, 0, (regmatch_t *) NULL, opts); // | REG_NOSUB); // TODO: can't NOSUB here, that goes to regcomp!!

    if( err == REG_NOMATCH ) {
        RETVAL = 0;

    } else if( err ) {
        regerror(err, r, (char *)errmsg, 250); // 255 or 256?  screw it, 250
        croak("error compiling regular expression, %s", errmsg);

    } else {
        RETVAL = 1;
    }

#line 275 "Regex.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_POSIX__Regex_regexec_wa); /* prototype to pass -Wmissing-prototypes */
XS(XS_POSIX__Regex_regexec_wa)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "POSIX::Regex::regexec_wa", "self, tomatch, opts");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	self = ST(0);
	char *	tomatch = (char *)SvPV_nolen(ST(1));
	int	opts = (int)SvIV(ST(2));
#line 118 "Regex.xs"
    regex_t *r;
    HV* me;
    int err;
    char *errmsg[256];
    regmatch_t mat[10];
    int i,e,s;

    AV* retav = newAV();

    if( !sv_isobject(self) )
        croak("error trying to compile regular in an unblessed reference");

    me = (HV*) SvRV(self); // de-reference us
    if( SvTYPE(me) != SVt_PVHV )
        croak("error trying to compile regular in a blessed reference that isn't a hash reference");

    // SV**  hv_fetch(HV*, const char* key, U32 klen, I32 lval); lval indicates whether this is part of a store operation also
    r = (regex_t *) SvUV(*(hv_fetch(me, regpk, regpk_len, 0)));

#line 317 "Regex.c"
	AV *	RETVAL;
#line 138 "Regex.xs"
    err = regexec(r, tomatch, 10, mat, opts);

    RETVAL = retav;

    if( err == REG_NOMATCH ) {
        // twiddle baby

    } else if( err ) {
        regerror(err, r, (char *)errmsg, 250); // 255 or 256?  screw it, 250
        croak("error compiling regular expression, %s", errmsg);

    } else {
        // find substrings and push them into retav
        for(i=0; i<10; i++) {
            s = mat[i].rm_so;
            e = mat[i].rm_eo;

            if( s==-1 || e==-1 ) {
                break;

            } else {
                av_push(retav, newSVpvn(tomatch+s, e-s));
            }
        }
    }

#line 346 "Regex.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_POSIX__Regex); /* prototype to pass -Wmissing-prototypes */
XS(boot_POSIX__Regex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("POSIX::Regex::constant", XS_POSIX__Regex_constant, file);
        newXS("POSIX::Regex::regcomp", XS_POSIX__Regex_regcomp, file);
        newXS("POSIX::Regex::cleanup_memory", XS_POSIX__Regex_cleanup_memory, file);
        newXS("POSIX::Regex::regexec", XS_POSIX__Regex_regexec, file);
        newXS("POSIX::Regex::regexec_wa", XS_POSIX__Regex_regexec_wa, file);
    XSRETURN_YES;
}

